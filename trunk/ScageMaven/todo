RoadMap
v0.5
* physics перенести в support, сделать по аналогии с tracer. До меня внезапно дошло, что в чем-то эти две
структуры весьма схожи. (done)
* переименовать --> в более простое addPhysical (done)
* newtracer перенести в tracer, tracer удалить (done)
* Переименовать базовый класс Tracer в ScageTracer (done)
* В tracer в функции traces добавить отдельные аргументы rangex и rangey (вместо общего range по обоим осям
сейчас) (done)
* Также добавить функцию, возвращающую объекты только с заданной точки (done)
* Поправить баг в updateLocation - если trace.id не был добавлен и не существует в traces_in_coord (done)
* В Renderer в методы draw* добавить аргумент _color, равный по умолчанию текущему цвету. (done)
* добавить функционал по вводу строк (отдельное окошко на свинге с простым текстовым полем, ввод по ctrl-enter)
* Добавить метод, рисующий точку (хочу себе навороченный бейсик)) (done)
* сообщения в логах при удалении операций из ScageScreen (done)

----------------
мб все настройки, начальные параметры вывести в *.properties. Тогда все можно переписать трейтами..
--
тогда будут траблы, если например в клиентском приложении требуется два трейсера в одном классе итд
и вообще, трейт - это если все-таки нужны какие то абстрактные методы

trait ScageTracer

подумать над вменяемым, красивым и производительным логированием

Trace extends State
просто и гениально :3
--
свои подводны камни тут тоже есть. Вызов getState начитывал каждый раз в State нужные параметры, и таким образом их
актуальность гарантировалась. Сейчас ничего такого не гарантируется. Более того, любой может сделать любой put в trace!
--
Полный фейл. Устранение подводных камней чересчур усложняет код движка. Откатываюсь назад

добавить в randomPoint/randomCoord условие, по которому производить генерацию
--
подумал и решил, что это лишнее, потому что скорость работы этих функций более не будет гарантированной
лучше решать проблему отсеивания нужных случайных позиций средствами клиентского приложения (как в Snake)

pointMatrix --> createMatrix
--
удалил совсем

продумать еще раз добавление action от условий:
условие выполнения action, или период между выполнениями, условие удаления. события при удалении...

В движке есть следующие компоненты:
ScageScreen
Controller + Renderer + ScageColors + Keyboard + Mouse
ScageProperties
ScageMessages
NetServer + NetClient
Tracer
ScagePhysics
Постараться, чтобы они не зависили друг от друга, чтобы каждый из этих комопнентов можно было использовать отдельно от
движка.

есть operation_id - для скринов и рендеров, есть trace_id - для трейсов и есть disaplylist_key - для дисплейных списков.
последний начинается с 10000 в качестве воркэраунда для одного шняги. Код практически одинаковый.
Мб сделать единый счетчик для всего вообще.
--
и перефигачить в Long

main screen - сделать единственным в системе, или оставить текущее положение? Вариант ТЗ:
при создании объекта ScageScreen в качестве параметра передавать имя. Первый созданный скрин станет main, для него
будут начитаны переданные проперти. Если проперти не переданы, пытаемся прочитать файл "имя скрина".toLower+".properties"
Главный скрин сейчас по сути - если для него вызвать stop, закрывать программу полностью. В принципе можно сделать программу
без мейн скрина (все скрины - не мейн), и программу с несколькими мейнами. Только смысл? Аналогично с пропертями: можно
переначитывать разные файлы несколько раз в программе в зависимости от. Другое дело, что это можно сделать и безотносительно
к системе скринов..
В общем, первый запущенный скрин становится мейном. Мейн в приложении может быть только один. Если мейн закрылся, приложение
в целом тоже. Относительно мейна начитываются проперти
--
переусложнения и ненужные ограничения, пока отказался

система эвентов в ScageScreen: onEvent(HERO_DIES) {...}, callEvent(HERO_DIES) итд

мб допилить, чтобы можно было все параметры задавать как параметры (некоторые сейчас можно только через
файл .properties)

удалять рендеры (мб и контролы)


su.msk.dunno -> net.eredory

продумать:
  * поставку в виде web start
  * поставку в виде апплета
  * продумать сетевой режим через интернет

В общем, мб все отдельные сущности поставлять в двух видах: синглтонами и классами
Например, ScageMessages - классом, чтобы можно было в одном приложении юзать разные шрифты разных размеров итд

Также мб сделать реализации некоторых вещей сразу встроенными в скрины (типа ФизиксСкрин, НетСкрин)
Возможно, что-то можно сделать также трейтами, чтобы еще удобнее было собирать приложение как конструктор
из компонентов

сделать сетевые сущности синглтонами или классами?
  плюсы синглтонов: удобнее синтаксис, можно статически импортить содержимое NetServer/NetClient, и сразу писать
  предметный код, не создавая никаких объектов. Также, более чистенько выглядит взаимодействие
  NetServer - ClientHandler (не надо соображать, выносить ли порт, макс_клиентс, и чек_таймаут в отдельный
  объект, начитывать из файла, или задавать параметром для каждого класса НетСервер и передавать
  клиентхэндлеру нужный ему чек_таймаут...)

  плюсы классов: шире возможности. Можно создавать много разных серверов и клиентов на разных портах и работать
  со всеми одновременно. Вопрос, нужно ли это. Ладно, если будет нужно, перепишу.

запилить режим работы без графики

сделать нормальный общий Logger, который принимает by-name параметры и делает проверку isDebugEnabled итд

дописать в ScageMessage методы print*, принимающие Vec

переименовать в Renderer: createDisplayList -> image, createAnimation -> animation (done)

Раз уж удаление операций вроде фурычит, мб придумать какой-нить механизм самоудаления операций...

в ScageScreen добавить функции, принимающие списки айдишников операций и удаляющие соотв операции

придумать dsl для парсинга State
--
Нужен более простой синтакисис работы с классом State. JSON-like стиль в целом хорош, но тоже может стать болью в
заднице, когда мы спускаемся на более низкие уровни вложенности. Кроме того нужно продумать задание правил и
зависимостей между значениями внутри State (возможно не в рамках Scage, возможно только в Blamer)

дописать в tracer методы, возвращающие случайные координаты

дальнейший рефакторинг: избавиться от пакета single, перенеся все из него в support и еще куда надо. Пакет screens
cтановится единственным, и его можно поднять на уровень вверх - su.msk.dunno.scage

начать писать комментарии в формате javadoc

Мб объединить генерацию дисплейных списокв в UnicodeFont с генерацией в Renderer, для остальной части Scage

еще раз продумать апи physics
--
Вообще, тут не надо думать, тут просто прогать надо, кучу разных проектов, где задействован физический движок. По мере
прояснения, что и где требуется и как применять, будет яснее и насчет ТЗ на апи.

доделать drawPolygon и drawFilledPolygon

Реализовать механизм ввода текстовой информации

Переделать Tracer, чтобы сам вычислял где какой трейс лежит (хранил мап)

Мб завести иерархию файлов строк, которые читает движок при запуске, или просто на этапе сборки мавеном начитывать в один
файл из умолчальных файлов и из application-specific.

Поправить взаимодействие Renderer со ScageScreen в случае, когда мы - main_screen

Переделать цветные строки

Апдейт пропертей: возможность задавать цвета, а также векторные величины (из двух значений)

Мб все-таки хранить файлы resources внутри джарника программы, как все крутые пацаны делают

Надо разработать план по описанию движка Scage: словесное описание, примеры кода, готовые приложения разные, куча
картинок. Подробное описание способов быстрого создания нового проекта (через мавеновский архетип), сборки готового
приложения. Все это на русском, потом на английский перевести (как можно быстрее).

Добавить поддержку мышки в Controller

возможность определять проперти через другие проперти
name = $app_name - $version

Надо продумать возможность перезапуска игры связкой exit - init, или просто init, чтобы можно было все грамотно
инициализировать - в частности, для физического движка чтобы все работало