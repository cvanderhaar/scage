RoadMap
v0.5
* physics перенести в support, сделать по аналогии с tracer. До меня внезапно дошло, что в чем-то эти две
структуры весьма схожи. (done)
* переименовать --> в более простое addPhysical (done)
* newtracer перенести в tracer, tracer удалить (done)
* Переименовать базовый класс Tracer в ScageTracer (done)
* В tracer в функции traces добавить отдельные аргументы rangex и rangey (вместо общего range по обоим осям
сейчас) (done)
* Также добавить функцию, возвращающую объекты только с заданной точки (done)
* Поправить баг в updateLocation - если trace.id не был добавлен и не существует в traces_in_coord (done)
* В Renderer в методы draw* добавить аргумент _color, равный по умолчанию текущему цвету. (done)
* добавить функционал по вводу строк (отдельное окошко на свинге с простым текстовым полем, ввод по ctrl-enter)
* Добавить метод, рисующий точку (хочу себе навороченный бейсик)) (done)
* сообщения в логах при удалении операций из ScageScreen (done)

----------------
аналогично drawPoints - drawLines

написать апи для проигрывания анимации

мелкие оптимизации:
метод removeTrace/removeTraceById (один типа, чтобы не было лишнего foreach), итд

подумать на досуге о возможности переполнения айдишников и возможном замедлении работы при логировании
их генерации (в режиме дебаг, при добавлении новых трейсов, например)

начать ботать Java Web Start. В перспективе это должно стать профилем в pom.xml (done)
--
крутота!

новый метод в трейсере: removeTraceByPoint/removeTraceByCoord
--
необходимость пока под вопросом

сообщение в логе при постановке/снятии с паузы
--
нужно например за тем, чтобы иметь возможность все же отслеживать состояние "на паузе/не на паузе", даже
если в интерфейсе это нигде не отображается никак (клиентский разработчик может в программе )

outsidePoint(...) -> point(...)
--
нее: метод point из CoordTracer перенести в ScageTRacer (done)

мб переписать методы типа drawPolygon итд, принимающие произвольное количество координат: сначала цвет,
потом координаты. Это избавит от дополнительного метода (вроде)

допилить drawPoint чтобы принимал список точек (done)
--
метод drawPoints


В ScageMessage добавить методы принимающие Vec вместо float, float

сделать клавишу "any key" =) (done)

Возможность задания периодичности работы action'ов by-value значением, то есть возможность менять ее на ходу  (done)
--
Сделано. Оставлен предыдущий вариант - статичный период между выполнением action'ов: actionWithStaticPeriod
Благодаря опциям компилятора он даже может быть немножко оптимизированный..)

Возможность передавать State в событийном фреймворке в ScageScreen
--
снабдить логами событийный фреймворк

мб все настройки, начальные параметры вывести в *.properties. Тогда все можно переписать трейтами..
--
тогда будут траблы, если например в клиентском приложении требуется два трейсера в одном классе итд
и вообще, трейт - это если все-таки нужны какие то абстрактные методы

trait ScageTracer
--
фейл. Нельзя иметь одноименные trait и класс. Так что уж лучше класс

Trace extends State
просто и гениально :3
--
свои подводны камни тут тоже есть. Вызов getState начитывал каждый раз в State нужные параметры, и таким образом их
актуальность гарантировалась. Сейчас ничего такого не гарантируется. Более того, любой может сделать любой put в trace!
--
Полный фейл. Устранение подводных камней чересчур усложняет код движка. Откатываюсь назад

pointMatrix --> createMatrix   (done)
--
удалил совсем

продумать еще раз добавление action от условий:
условие выполнения action, или период между выполнениями, условие удаления. события при удалении... (done)
--
реализовал просто период между выполнениями, но он может динамически меняться

В движке есть следующие компоненты:
ScageScreen
Controller + Renderer + ScageColors + Keyboard + Mouse
ScageProperties
ScageMessages
NetServer + NetClient
Tracer
ScagePhysics
Постараться, чтобы они не зависили друг от друга, чтобы каждый из этих комопнентов можно было использовать отдельно от
движка.

есть operation_id - для скринов и рендеров, есть trace_id - для трейсов и есть disaplylist_key - для дисплейных списков.
последний начинается с 10000 в качестве воркэраунда для одного шняги. Код практически одинаковый.
Мб сделать единый счетчик для всего вообще.              (done)
--
и перефигачить в Long
--
сделано. Long не удалось из-за дисплейных списокв

main screen - сделать единственным в системе, или оставить текущее положение? Вариант ТЗ:
при создании объекта ScageScreen в качестве параметра передавать имя. Первый созданный скрин станет main, для него
будут начитаны переданные проперти. Если проперти не переданы, пытаемся прочитать файл "имя скрина".toLower+".properties"
Главный скрин сейчас по сути - если для него вызвать stop, закрывать программу полностью. В принципе можно сделать программу
без мейн скрина (все скрины - не мейн), и программу с несколькими мейнами. Только смысл? Аналогично с пропертями: можно
переначитывать разные файлы несколько раз в программе в зависимости от. Другое дело, что это можно сделать и безотносительно
к системе скринов..
В общем, первый запущенный скрин становится мейном. Мейн в приложении может быть только один. Если мейн закрылся, приложение
в целом тоже. Относительно мейна начитываются проперти
--
переусложнения и ненужные ограничения, пока отказался

система эвентов в ScageScreen: onEvent(HERO_DIES) {...}, callEvent(HERO_DIES) итд     (done)
--
реализовал, но пока так и не придумал, где это применить. Коды эвентов - строковые константы

мб допилить, чтобы можно было все параметры задавать как параметры (некоторые сейчас можно только через
файл .properties)

удалять рендеры (мб и контролы)      (partly-done)
--
сделал удаление рендеров. про контролы пока непонятно, нужно ли

su.msk.dunno -> net.eredory

продумать:
  * поставку в виде web start
  * поставку в виде апплета
  * продумать сетевой режим через интернет

В общем, мб все отдельные сущности поставлять в двух видах: синглтонами и классами
Например, ScageMessages - классом, чтобы можно было в одном приложении юзать разные шрифты разных размеров итд

Также мб сделать реализации некоторых вещей сразу встроенными в скрины (типа ФизиксСкрин, НетСкрин)
Возможно, что-то можно сделать также трейтами, чтобы еще удобнее было собирать приложение как конструктор
из компонентов

сделать сетевые сущности синглтонами или классами?
  плюсы синглтонов: удобнее синтаксис, можно статически импортить содержимое NetServer/NetClient, и сразу писать
  предметный код, не создавая никаких объектов. Также, более чистенько выглядит взаимодействие
  NetServer - ClientHandler (не надо соображать, выносить ли порт, макс_клиентс, и чек_таймаут в отдельный
  объект, начитывать из файла, или задавать параметром для каждого класса НетСервер и передавать
  клиентхэндлеру нужный ему чек_таймаут...)

  плюсы классов: шире возможности. Можно создавать много разных серверов и клиентов на разных портах и работать
  со всеми одновременно. Вопрос, нужно ли это. Ладно, если будет нужно, перепишу.

запилить режим работы без графики

сделать нормальный общий Logger, который принимает by-name параметры и делает проверку isDebugEnabled итд
--
подумать над вменяемым, красивым и производительным логированием
--
добавить в него возможность продолжать писать лог на той же строке

дописать в ScageMessage методы print*, принимающие Vec

переименовать в Renderer: createDisplayList -> image, createAnimation -> animation (done)

Раз уж удаление операций вроде фурычит, мб придумать какой-нить механизм самоудаления операций... (done)
--
сделал метод currentOperaion в объекте ScageScreen - возвращает id текущей операции. Таким образом операция может
прочитать его и удалить, удалив таким образом себя

в ScageScreen добавить функции, принимающие списки айдишников операций и удаляющие соотв операции (done)

придумать dsl для парсинга State
--
Нужен более простой синтакисис работы с классом State. JSON-like стиль в целом хорош, но тоже может стать болью в
заднице, когда мы спускаемся на более низкие уровни вложенности. Кроме того нужно продумать задание правил и
зависимостей между значениями внутри State (возможно не в рамках Scage, возможно только в Blamer)

дописать в tracer методы, возвращающие случайные координаты (done)
--
добавить в randomPoint/randomCoord условие, по которому производить генерацию
--
подумал и решил, что это лишнее, потому что скорость работы этих функций более не будет гарантированной
лучше решать проблему отсеивания нужных случайных позиций средствами клиентского приложения (как в Snake)

дальнейший рефакторинг: избавиться от пакета single, перенеся все из него в support и еще куда надо. Пакет screens
cтановится единственным, и его можно поднять на уровень вверх - su.msk.dunno.scage

начать писать комментарии в формате javadoc

Мб объединить генерацию дисплейных списокв в UnicodeFont с генерацией в Renderer, для остальной части Scage
--
сложновато

еще раз продумать апи physics
--
Вообще, тут не надо думать, тут просто прогать надо, кучу разных проектов, где задействован физический движок. По мере
прояснения, что и где требуется и как применять, будет яснее и насчет ТЗ на апи.

доделать drawPolygon и drawFilledPolygon    (done)
--
не помню, что я там хотел доделать, но наверное доделал, пушо сейчас к этому апи претензий нет

Реализовать механизм ввода текстовой информации
--
окошко свинговое с текстовым полем

Переделать Tracer, чтобы сам вычислял где какой трейс лежит (хранил мап) (done)

Мб завести иерархию файлов строк, которые читает движок при запуске, или просто на этапе сборки мавеном начитывать в один
файл из умолчальных файлов и из application-specific.

Поправить взаимодействие Renderer со ScageScreen в случае, когда мы - main_screen (done)

Переделать цветные строки

Апдейт пропертей: возможность задавать цвета, а также векторные величины (из двух значений)

Мб все-таки хранить файлы resources внутри джарника программы, как все крутые пацаны делают
--
аналогично мб проперти

Надо разработать план по описанию движка Scage: словесное описание, примеры кода, готовые приложения разные, куча
картинок. Подробное описание способов быстрого создания нового проекта (через мавеновский архетип), сборки готового
приложения. Все это на русском, потом на английский перевести (как можно быстрее).

Добавить поддержку мышки в Controller (done)

возможность определять проперти через другие проперти
name = $app_name - $version

Надо продумать возможность перезапуска игры связкой exit - init, или просто init, чтобы можно было все грамотно
инициализировать - в частности, для физического движка чтобы все работало  (done)